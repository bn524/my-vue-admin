# 后台管理系统开发&问题排查日志
**技术栈**：前端（Vue3 + Pinia + Vite）、后端（FastAPI + YOLOv8 + SQLite）  
**核心功能**：目标检测、检测记录管理、登录权限控制  


## 一、初始问题：检测记录不显示&统计数据异常（第一阶段）
### 1. 需求与问题现象
用户已实现YOLOv8目标检测后端和Vue3管理前端，但存在以下问题：
- 检测后仅“检测次数”增加，**具体检测记录（类别、坐标等）不显示**；
- “检测对象数量”始终不变，统计数据异常；
- 后台管理系统无法查看历史检测详情。


### 2. 问题分析（前后端联动排查）
#### （1）后端代码验证（`main.py`）
- 后端`DetectionRecord`模型设计完整，包含`detection_results`（存储检测详情JSON）和`detection_count`（对象数量）；
- `/detect`接口能正确将检测结果写入SQLite，`/detections`接口可返回历史记录，**后端逻辑无问题**。

#### （2）前端问题定位（核心问题点）
| 问题模块                | 具体原因                                                                 |
|-------------------------|--------------------------------------------------------------------------|
| `stores/detection.js`   | 1. 热门检测类别`topCategories`硬编码模拟数据，未基于实际检测结果动态计算；<br>2. `todayDetections`统计逻辑错误，未过滤当天记录。 |
| `views/detections.vue`  | 1. “今日检测对象数量”硬编码为150，未从检测记录累加；<br>2. 日期筛选（今天/本周）功能未实现；<br>3. 检测后未刷新历史记录数据。 |
| `services/api.js`       |  axios实例默认设置`multipart/form-data`头，可能影响GET请求（非致命）。     |


### 3. 解决方案（前端代码修改）
#### （1）状态管理优化（`stores/detection.js`）
- 将`topCategories`改为计算属性，基于`detectionHistory`动态统计检测类别数量：
  ```javascript
  const topCategories = computed(() => {
    const categoryCount = {};
    detectionHistory.value.forEach(record => {
      record.detectionData?.detections?.forEach(d => {
        categoryCount[d.class] = (categoryCount[d.class] || 0) + 1;
      });
    });
    // 排序取前5类并计算占比
    return Object.entries(categoryCount)
      .map(([name, count]) => ({ name, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 5)
      .map(item => ({
        ...item,
        percentage: Math.round((item.count / total) * 100)
      }));
  });
  ```
- 修复`todayDetections`统计逻辑，过滤当天记录：
  ```javascript
  const today = new Date().toISOString().split('T')[0];
  todayDetections.value = detectionHistory.value.filter(
    record => record.uploadTime.split('T')[0] === today
  ).length;
  ```

#### （2）检测记录页面修复（`views/detections.vue`）
- 动态计算“今日检测对象数量”，从当天记录累加`objects`字段：
  ```javascript
  const todayObjects = allDetections
    .filter(d => d.uploadTime.split('T')[0] === today)
    .reduce((sum, d) => sum + d.objects, 0);
  todayStats.value = { detections: stats.today_detections, objects: todayObjects };
  ```
- 实现日期筛选功能，添加`isDateInRange`辅助函数：
  ```javascript
  const isDateInRange = (dateString, range) => {
    const date = new Date(dateString);
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    switch(range) {
      case 'today': return date >= today;
      case 'week': return date >= new Date(today.setDate(today.getDate() - today.getDay()));
      default: return true;
    }
  };
  ```
- 检测后刷新历史记录：在`handleFileUpload`中添加`await detectionStore.fetchDetectionHistory()`。


## 二、前端Bug修复（第二阶段）
### 1. Bug1：`split`方法调用错误（`Cannot read properties of undefined`）
#### （1）现象
控制台报错：`detection.js:90 Uncaught TypeError: Cannot read properties of undefined (reading 'split')`。

#### （2）原因
`record.image_size`可能为`null/undefined`，直接调用`split(',')`导致报错。

#### （3）修复
在`stores/detection.js`中添加安全处理：
```javascript
const imageSizeParts = record.image_size?.split(',') ?? []; // 可选链+默认空数组
const imageSize = imageSizeParts.map(Number).reverse();
detectionData: {
  image_size: imageSize.length === 2 ? imageSize : [0, 0], // 兜底默认值
}
```


### 2. Bug2：生命周期钩子警告（`onUnmounted is called when no active component`）
#### （1）现象
`onUnmounted`在`onMounted`异步回调中注册，导致无法关联组件实例。

#### （2）原因
Vue3生命周期钩子需在`setup()`同步阶段注册，`onMounted(async () => { onUnmounted(...) })`破坏实例关联。

#### （3）修复
将`onUnmounted`移到`setup`顶层，顶层定义定时器变量：
```javascript
// setup顶层定义
let statusCheckInterval = null;
// 顶层注册onUnmounted
onUnmounted(() => {
  if (statusCheckInterval) clearInterval(statusCheckInterval);
});
// onMounted中仅赋值定时器
onMounted(async () => {
  statusCheckInterval = setInterval(..., 30000);
});
```


### 3. Bug3：连接拒绝错误（`net::ERR_CONNECTION_REFUSED`）
#### （1）现象
前端请求`http://localhost:3000`被拒绝，后端实际运行在`8000`端口。

#### （2）原因
- Vite配置中代理地址错误，或`client.ts`硬编码`3000`端口；
- 前端服务未启动，或启动端口与配置不一致。

#### （3）修复
- 修正Vite代理配置（`vite.config.js`）：
  ```javascript
  server: {
    port: 8080,
    proxy: {
      '/api': { target: 'http://localhost:8000', changeOrigin: true },
      '/thumbnails': { target: 'http://localhost:8000', changeOrigin: true }
    }
  }
  ```
- 确保后端先启动（`uvicorn main:app --port 8000`），再启动前端（`npm run dev`）。


### 4. Bug4：路由解析错误（`vite:import-analysis`）
#### （1）现象
Vite解析`router/index.js`时报错，指向`createRouter`实例创建。

#### （2）原因
- 路由中动态导入的视图组件路径错误（如`404.vue`不存在但配置了路由）；
- Pinia未在`main.js`中正确安装，导致路由守卫中`useAuthStore()`调用失败。

#### （3）修复
- 删除不存在的路由（如`404.vue`），确保组件路径与实际文件一致；
- 调整`main.js`中Pinia与路由的安装顺序：
  ```javascript
  import { createPinia } from 'pinia';
  const pinia = createPinia();
  createApp(App).use(pinia).use(router).mount('#app'); // 先装Pinia，再装路由
  ```


## 三、功能扩展：前端登录权限控制（第三阶段）
### 1. 需求
- 实现静态登录验证（用户名`admin`，密码`123456`）；
- Pinia管理登录状态，路由守卫控制未登录跳转；
- 页头显示登录状态（欢迎信息+登出按钮）。


### 2. 实现方案（核心代码模块）
#### （1）登录状态管理（`stores/auth.js`）
```javascript
export const useAuthStore = defineStore('auth', () => {
  const isLoggedIn = ref(false);
  const userName = ref('');
  const router = useRouter();

  // 静态登录验证
  const login = (username, password) => {
    if (username === 'admin' && password === '123456') {
      isLoggedIn.value = true;
      userName.value = username;
      localStorage.setItem('authState', JSON.stringify({ isLoggedIn, userName })); // 持久化
      return true;
    }
    return false;
  };

  // 登出（清除状态+跳登录页）
  const logout = () => {
    isLoggedIn.value = false;
    userName.value = '';
    localStorage.removeItem('authState');
    router.push('/login');
  };

  // 页面刷新恢复状态
  const initAuthState = () => {
    const saved = localStorage.getItem('authState');
    if (saved) {
      const { isLoggedIn: sIsLog, userName: sName } = JSON.parse(saved);
      isLoggedIn.value = sIsLog;
      userName.value = sName;
    }
  };

  return { isLoggedIn, userName, login, logout, initAuthState };
});
```

#### （2）路由守卫（`router/index.js`）
```javascript
router.beforeEach((to, from, next) => {
  const authStore = useAuthStore();
  authStore.initAuthState(); // 恢复状态

  const needAuth = to.meta.requireAuth;
  if (needAuth) {
    // 需要登录：已登录放行，未登录跳登录页（记录原目标）
    authStore.isLoggedIn ? next() : next({ name: 'Login', query: { redirect: to.fullPath } });
  } else {
    // 无需登录：已登录跳首页，避免重复登录
    to.name === 'Login' && authStore.isLoggedIn ? next('/dashboard') : next();
  }
});
```

#### （3）登录页（`views/Login.vue`）
- 简单表单（用户名/密码输入框），点击登录调用`authStore.login()`；
- 登录失败显示错误提示（如“用户名或密码错误”）；
- 登录成功跳转首页（或原目标页面）。

#### （4）页头集成登录状态（`components/header.vue`）
- 登录状态：显示“欢迎，admin”+下拉登出菜单；
- 未登录状态：显示“登录”按钮，点击跳登录页；
- 点击页面其他区域关闭登出菜单，优化交互。


## 四、最终效果与关键知识点总结
### 1. 功能验证
- 检测功能：上传图片→YOLOv8检测→记录实时显示（类别、置信度、边界框）；
- 统计数据：今日检测次数/对象数量动态计算，热门类别实时更新；
- 权限控制：未登录访问`/detections`自动跳登录页，登出后清除状态；
- 兼容性：页面刷新后登录状态、检测记录不丢失。


### 2. 关键技术点
1. **Pinia状态管理**：跨组件共享检测记录、登录状态，结合`localStorage`持久化；
2. **Vue路由守卫**：全局前置守卫实现权限控制，解决“未登录访问受限页面”问题；
3. **前后端数据联动**：前端通过Axios调用FastAPI接口，处理JSON数据解析与渲染；
4. **错误处理**：安全调用`split()`、`toFixed()`等方法，避免`undefined`报错。